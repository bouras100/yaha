<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Dino Devil â€” Ø¬Ø±ÙŠ Ù…Ø¹ Ù…ØµØ§Ø¦Ø¯ Ø§Ù„Ø´ÙŠØ·Ø§Ù†</title>
<link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;700&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#0e0e10; --panel: rgba(0,0,0,0.6); --accent:#e74c3c; --muted:#aaa; --text:#fff; }
  *{box-sizing:border-box;font-family:'Cairo',sans-serif}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);display:flex;align-items:center;justify-content:center}
  .container{width:980px;max-width:96vw;padding:14px;text-align:center;position:relative}
  .hud{display:flex;gap:12px;justify-content:space-between;align-items:center;margin-bottom:8px;flex-wrap:wrap}
  .panel{background:var(--panel);padding:8px 12px;border-radius:8px}
  .points{font-size:20px;background:linear-gradient(90deg,#222,#333);padding:8px 12px;border-radius:8px}
  canvas{display:block;margin:6px auto;border-radius:8px;background:#222;box-shadow:0 6px 24px rgba(0,0,0,0.6);max-width:100%}
  .btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
  .btn.primary{background:var(--accent);color:#fff}
  .btn.space{background:#3498db;color:#fff}
  .center-screen{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:60}
  .start-screen, .end-screen{background:rgba(0,0,0,0.9);padding:18px 22px;border-radius:12px;min-width:320px;color:#fff}
  .message-center{position:absolute; left:50%; top:40%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.7); color:#fff; padding:14px 22px; border-radius:10px; font-weight:700; font-size:20px; pointer-events:none; opacity:0; transition: opacity 300ms ease, transform 300ms ease; z-index:40;}
  .message-center.show{ opacity:1; transform:translate(-50%,-46%); }
  .controls-bottom{display:flex; gap:10px; align-items:center; justify-content:center; margin-top:8px; flex-wrap:wrap}
  .difficulty {display:flex; gap:8px; align-items:center}
  .small{font-size:13px;color:var(--muted)}
  .slider{width:160px}
  .top-right-controls{display:flex;gap:8px;align-items:center}
  #muteBtn{border-radius:8px;padding:8px}
  @media (max-width:720px){
    .slider{width:120px}
    .start-screen,.end-screen{min-width:260px}
    .hud{flex-direction:column;align-items:flex-start}
  }
  /* spike style for markers in UI (not canvas) */
  .spike-mark{width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:16px solid #fff;display:inline-block;margin:0 4px}
</style>
</head>
<body>
  <div class="container" id="app">
    <div class="hud">
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
        <div class="panel" id="instructions">ğŸ”¥ ØªØ­Ø¯Ù‰ Ø§Ù„Ø´ÙŠØ·Ø§Ù†! Ø§Ø¶ØºØ· Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ù„Ù„Ù‚ÙØ² â€” Ø§Ù„Ø¢Ù† Ù…Ø¹ Ù…ØµØ§Ø¦Ø¯ ÙˆØ¹Ù‚Ø¨Ø§Øª. ğŸ”¥</div>
        <div class="points" id="score">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
      </div>

      <div class="top-right-controls" style="display:flex;gap:8px;align-items:center">
        <div class="small" id="best">Ø§Ù„Ø£ÙØ¶Ù„: 0</div>
        <button id="muteBtn" class="btn" title="ÙƒØªÙ…/ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª">ğŸ”Š</button>
        <button id="btn-share" class="btn">Ù…Ø´Ø§Ø±ÙƒØ©</button>
      </div>
    </div>

    <div style="position:relative">
      <div id="message" class="message-center">Ù…Ø³ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯!</div>
      <canvas id="game" width="920" height="360" aria-label="Ù„Ø¹Ø¨Ø© Ø¯ÙŠÙ†Ùˆ Ø¯ÙŠÙÙ„ â€” Ø¬Ø±ÙŠ Ù…Ø¹ Ù…ØµØ§Ø¦Ø¯ Ø§Ù„Ø´ÙŠØ·Ø§Ù†"></canvas>
    </div>

    <div class="controls-bottom">
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <div class="small">Ø¬Ø§Ø°Ø¨ÙŠØ©</div>
        <input id="slider-gravity" class="slider" type="range" min="0.2" max="2.0" step="0.05" value="0.6">
        <div class="small" id="gravity-value">0.60</div>

        <div class="small">Ù‚ÙˆØ© Ø§Ù„Ù‚ÙØ²</div>
        <input id="slider-jump" class="slider" type="range" min="6" max="20" step="1" value="12">
        <div class="small" id="jump-value">12</div>

        <button id="btn-space" class="btn space">ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„ÙØ¶Ø§Ø¡</button>
      </div>

      <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
        <div class="difficulty">
          <label class="small">Ø§Ù„ØµØ¹ÙˆØ¨Ø©:</label>
          <button id="diff-easy" class="btn">Ø³Ù‡Ù„</button>
          <button id="diff-normal" class="btn primary">Ø¹Ø§Ø¯ÙŠ</button>
          <button id="diff-hard" class="btn">ØµØ¹Ø¨</button>
        </div>

        <div style="color:var(--muted);font-size:13px">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <span id="level">1</span></div>
        <button id="btn-restart" class="btn primary" style="display:none">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
      </div>
    </div>
  </div>

  <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© -->
  <div id="startScreen" class="center-screen start-screen">
    <h2>ğŸ¦– Dino Devil </h2>
    <p>Ø§Ø¶ØºØ· play Ù„Ù„Ø¨Ø¯Ø¡. Ø§Ù„Ø¢Ù† ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ù…ÙŠØ±ØŒ Ù…Ù†Ø§Ø´ÙŠØ± Ø¯ÙˆÙ‘Ø§Ø±Ø© ÙˆÙ…ØµØ§Ø¦Ø¯ ØªØ³Ù‚Ø· Ø¹Ù„ÙŠÙƒ!</p>
    <div style="display:flex;gap:8px;justify-content:center;margin-top:10px;flex-wrap:wrap">
      <button id="startEasy" class="btn">play (Ø³Ù‡Ù„)</button>
      <button id="startNormal" class="btn primary">play (Ø¹Ø§Ø¯ÙŠ)</button>
      <button id="startHard" class="btn">play (ØµØ¹Ø¨)</button>
    </div>
    <p class="small" style="margin-top:10px">ØªØ­ÙƒÙ‘Ù… Ø¨Ø§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ© ÙˆØ§Ù„Ù‚ÙØ² Ù…Ù† Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨.</p>
  </div>

  <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ© -->
  <div id="endScreen" class="center-screen end-screen" style="display:none">
    <h3 id="endTitle">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h3>
    <p id="endScore">Ù†Ù‚Ø§Ø·Ùƒ: 0</p>
    <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
      <button id="restartFromEnd" class="btn primary">Ø¥Ø¹Ø§Ø¯Ø©</button>
      <button id="shareFromEnd" class="btn">Ù…Ø´Ø§Ø±ÙƒØ©</button>
    </div>
  </div>

  <!-- Ø£ØµÙˆØ§Øª (ÙŠÙ…ÙƒÙ† ØªØ±ÙƒÙ‡Ø§ ÙØ§Ø±ØºØ© Ø£Ùˆ ÙˆØ¶Ø¹ Ø±ÙˆØ§Ø¨Ø·) -->
  <audio id="bgMusic" loop preload="auto" src=""></audio>
  <audio id="jumpSound" preload="auto" src=""></audio>
  <audio id="hitSound" preload="auto" src=""></audio>

<script>
/* ---------- DOM ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const levelEl = document.getElementById('level');
const messageEl = document.getElementById('message');

const sliderGravity = document.getElementById('slider-gravity');
const gravityValueEl = document.getElementById('gravity-value');
const sliderJump = document.getElementById('slider-jump');
const jumpValueEl = document.getElementById('jump-value');
const btnSpace = document.getElementById('btn-space');
const btnRestart = document.getElementById('btn-restart');
const btnShare = document.getElementById('btn-share');
const muteBtn = document.getElementById('muteBtn');

const diffEasy = document.getElementById('diff-easy');
const diffNormal = document.getElementById('diff-normal');
const diffHard = document.getElementById('diff-hard');

const startScreen = document.getElementById('startScreen');
const startEasy = document.getElementById('startEasy');
const startNormal = document.getElementById('startNormal');
const startHard = document.getElementById('startHard');

const endScreen = document.getElementById('endScreen');
const restartFromEnd = document.getElementById('restartFromEnd');

const bgMusic = document.getElementById('bgMusic');
const jumpSound = document.getElementById('jumpSound');
const hitSound = document.getElementById('hitSound');

/* ---------- defaults ---------- */
let W = canvas.width, H = canvas.height;
const GROUND_Y = 300;
let running = false;

let player = { x:80, y: GROUND_Y - 60, w:48, h:48, vy:0, onGround:true, color:'#ff3333', wings:false };
let baseGravity = parseFloat(sliderGravity.value);
let gravity = baseGravity;
let baseJump = parseInt(sliderJump.value,10);
let jumpForce = baseJump;

let points = 0;
let best = parseInt(localStorage.getItem('dino_best')||'0',10) || 0;
let level = 1;
let muteState = false;

/* world / distance */
let worldX = 0;              // how far the world scrolled (used for spawn by distance)
let speed = 180;             // pixels per second world speed (increases with level)
let spawnDistance = 350;     // distance between spawns (will vary)
let lastSpawnAt = 0;

/* obstacles */
let obstacles = []; // each: {type, x, w, h, active, vx, ay, state, extra...}

/* background */
const levelColors = ['#222','#331111','#441111','#661111','#991111','#cc0000','#330033'];
let bgColor = levelColors[0], targetBg = bgColor, bgLerpT = 0;

/* ---------- helpers ---------- */
function lerp(a,b,t){ return a + (b-a)*t; }
function hexToRgb(hex){ hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(ch=>ch+ch).join(''); const bigint = parseInt(hex,16); return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 }; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ---------- difficulty UI ---------- */
function applyDifficulty(diff){
  diffEasy.classList.toggle('primary', diff==='easy');
  diffNormal.classList.toggle('primary', diff==='normal');
  diffHard.classList.toggle('primary', diff==='hard');
  if(diff==='easy'){ speed = 150; spawnDistance = 420; }
  else if(diff==='normal'){ speed = 200; spawnDistance = 350; }
  else { speed = 260; spawnDistance = 300; }
}
diffEasy.addEventListener('click', ()=>applyDifficulty('easy'));
diffNormal.addEventListener('click', ()=>applyDifficulty('normal'));
diffHard.addEventListener('click', ()=>applyDifficulty('hard'));
applyDifficulty('normal');

/* ---------- physics & input ---------- */
function startInitial(){
  bestEl.textContent = 'Ø§Ù„Ø£ÙØ¶Ù„: ' + best;
  gravity = baseGravity; jumpForce = baseJump;
  gravityValueEl.textContent = gravity.toFixed(2); jumpValueEl.textContent = jumpForce.toString();
}
startInitial();

function jump(){
  if(!running) return;
  if(player.onGround){
    player.vy = -jumpForce;
    player.onGround = false;
    try{ if(!muteState && jumpSound.src){ jumpSound.currentTime = 0; jumpSound.play(); } }catch(e){}
  }
}

document.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); jump(); }});
canvas.addEventListener('mousedown', ()=>{ jump(); });
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); jump(); });

sliderGravity.addEventListener('input', (e)=>{
  baseGravity = parseFloat(e.target.value);
  gravityValueEl.textContent = baseGravity.toFixed(2);
  if(btnSpace.dataset.on === 'true'){ /* ignore while space mode on */ } else { gravity = baseGravity; }
});
sliderJump.addEventListener('input', (e)=>{ baseJump = parseInt(e.target.value,10); jumpForce = baseJump; jumpValueEl.textContent = jumpForce.toString(); });

btnSpace.addEventListener('click', ()=>{
  if(btnSpace.dataset.on === 'true'){
    btnSpace.dataset.on = 'false'; btnSpace.textContent = 'ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„ÙØ¶Ø§Ø¡';
    gravity = baseGravity; jumpForce = baseJump;
    gravityValueEl.textContent = gravity.toFixed(2); jumpValueEl.textContent = jumpForce.toString();
  } else {
    btnSpace.dataset.on = 'true'; btnSpace.textContent = 'Ø¥ÙŠÙ‚Ø§Ù ÙˆØ¶Ø¹ Ø§Ù„ÙØ¶Ø§Ø¡';
    gravity = 0.2; jumpForce = 8;
    gravityValueEl.textContent = gravity.toFixed(2); jumpValueEl.textContent = jumpForce.toString();
  }
});

/* ---------- obstacle generation (Ù…Ø³Ø§ÙØ©) ---------- */
function chooseObstacleSetForLevel(lv){
  // returns array of patterns to pick from
  const sets = [];
  // basic ground spikes
  sets.push([{type:'spike', w:40, h:40}]);
  // cluster of spikes
  sets.push([{type:'spike', w:30, h:36},{type:'spike', w:30, h:36},{type:'spike', w:30, h:36}]);
  // saw (flying/rolling)
  sets.push([{type:'saw', w:48, r:20, y:GROUND_Y-80}]);
  // saw + spikes
  sets.push([{type:'saw', w:48, r:20, y:GROUND_Y-120},{type:'spike', w:30, h:36}]);
  // moving spike (horizontal)
  sets.push([{type:'movingSpike', w:40, h:40, range:120, vy:0}]);
  // falling spike (drops after player passes)
  sets.push([{type:'fallSpike', w:40, h:40, delay:400}]);
  // chain of alternating
  sets.push([{type:'spike', w:30, h:36},{type:'saw', w:36, r:18, y:GROUND_Y-90},{type:'spike', w:30, h:36}]);

  // make tougher sets available after certain level
  if(lv>=4) sets.push([{type:'saw', w:60, r:28, y:GROUND_Y-140}]);
  if(lv>=6) sets.push([{type:'movingSpike', w:40, h:40, range:220, speed:160},{type:'spike', w:30, h:36}]);
  if(lv>=8) sets.push([{type:'spikeTall', w:48, h:80}]);

  return sets;
}

function spawnObstacles(){
  const sets = chooseObstacleSetForLevel(level);
  const pick = sets[Math.floor(Math.random()*sets.length)];
  let x = W + 20;
  for(let i=0;i<pick.length;i++){
    const item = JSON.parse(JSON.stringify(pick[i]));
    item.x = x;
    item.active = true;
    item.state = 'idle';
    item.vx = - (speed * (0.9 + Math.random()*0.3)); // base leftward
    if(item.type==='saw'){
      item.ang = 0;
      item.vang = (Math.random()>0.5?1:-1) * (0.02 + Math.random()*0.03);
      if(!item.y) item.y = GROUND_Y - 60 - Math.round(Math.random()*80);
      item.y0 = item.y;
    }
    if(item.type==='movingSpike'){
      item.ox = x;
      item.range = item.range || 120;
      item.dir = (Math.random()>0.5?1:-1);
      item.speed = item.speed || 120;
    }
    if(item.type==='fallSpike'){
      item.triggered = false;
      item.vy = 0;
      item.ay = 0.8;
      item.h = item.h || 40;
    }
    obstacles.push(item);
    x += (item.w || 40) + 20 + Math.floor(Math.random()*60); // spacing inside pattern
  }
}

/* ---------- collision helpers ---------- */
function rectsOverlap(a,b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

/* specialized: check triangle spike collision (approx) */
function spikeCollision(spk, ply){
  // approximate: if player's feet are below spike top and x overlaps spike base, collide
  const spikeTopY = GROUND_Y - spk.h;
  if(ply.y + ply.h >= spikeTopY + 4){ // close enough
    const spkLeft = spk.x;
    const spkRight = spk.x + spk.w;
    const plyLeft = ply.x;
    const plyRight = ply.x + ply.w;
    // require some horizontal overlap
    if(plyRight > spkLeft + 6 && plyLeft < spkRight - 6) return true;
  }
  return false;
}

/* ---------- rendering helpers ---------- */
function drawPlayer(){
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.w, player.h);
  // wings hint
  if(player.wings){
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillRect(player.x-10, player.y+6, 8, 10);
    ctx.fillRect(player.x+player.w+2, player.y+6, 8, 10);
  }
}

function drawGround(){
  ctx.fillStyle = '#444';
  ctx.fillRect(0, GROUND_Y, W, canvas.height - GROUND_Y);
  for(let i=0;i<W;i+=40){ ctx.fillStyle='rgba(0,0,0,0.06)'; ctx.fillRect(i, GROUND_Y+18, 30, 2); }
}

function drawSpike(spk){
  const x = spk.x, w = spk.w, h = spk.h;
  ctx.fillStyle = '#eee';
  ctx.beginPath();
  ctx.moveTo(x, GROUND_Y);
  ctx.lineTo(x + w/2, GROUND_Y - h);
  ctx.lineTo(x + w, GROUND_Y);
  ctx.closePath();
  ctx.fill();
  // dark edge
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.stroke();
}

function drawSpikeTall(spk){
  const x = spk.x, w = spk.w, h = spk.h;
  ctx.fillStyle = '#ddd';
  ctx.fillRect(x, GROUND_Y - h, w, h);
  ctx.fillStyle = '#bbb';
  ctx.fillRect(x+4, GROUND_Y - h + 6, w-8, h-6);
}

function drawSaw(s){
  const cx = s.x + (s.w/2), cy = s.y;
  const r = s.r || (s.w/2);
  // disc
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(s.ang);
  ctx.beginPath();
  ctx.arc(0,0,r,0,Math.PI*2);
  ctx.fillStyle = '#ddd';
  ctx.fill();
  // teeth
  const teeth = 12;
  for(let i=0;i<teeth;i++){
    const a1 = (i/teeth)*Math.PI*2;
    const x1 = Math.cos(a1)*(r-2), y1 = Math.sin(a1)*(r-2);
    const x2 = Math.cos(a1+Math.PI/teeth)*(r+6), y2 = Math.sin(a1+Math.PI/teeth)*(r+6);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.stroke();
  }
  ctx.restore();
}

/* ---------- game loop ---------- */
let lastTime = 0;
let rafId = null;
function gameOver(){
  stopRunning();
  try{ if(!muteState && hitSound.src){ hitSound.currentTime = 0; hitSound.play(); } }catch(e){}
  endScreen.style.display = 'block';
  document.getElementById('endScore').textContent = 'Ù†Ù‚Ø§Ø·Ùƒ: ' + Math.floor(points);
  document.getElementById('endTitle').textContent = 'âœ– ÙØ´Ù„Øª â€” Ù…Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ùˆ!';
}

function updateObstacles(dt){
  // update each obstacle position relative to world speed
  for(let ob of obstacles){
    if(!ob.active) continue;
    if(ob.type==='spike' || ob.type==='spikeTall'){
      ob.x += ob.vx * (dt/1000);
    } else if(ob.type==='saw'){
      ob.x += ob.vx * (dt/1000);
      ob.ang += ob.vang * dt;
      // saw can bob a bit
      ob.y = ob.y0 + Math.sin((worldX+ob.x)/120) * 6;
    } else if(ob.type==='movingSpike'){
      // horizontal oscillation around ox
      ob.ox = ob.ox || ob.x;
      ob.x = ob.ox + Math.sin((performance.now()+ob.ox)/1000) * ob.range * 0.5;
    } else if(ob.type==='fallSpike'){
      // move with world until player passed threshold
      // trigger when player x > spike.x - 50
      if(!ob.triggered && player.x > ob.x - 60){
        ob.triggered = true;
        ob.state = 'fall';
      }
      if(ob.state==='fall'){
        ob.vy += ob.ay;
        ob.y = (ob.y || (GROUND_Y - ob.h - 50)) + ob.vy;
        // if hits ground, make it stay and create small bounce
        if(ob.y + ob.h >= GROUND_Y){
          ob.y = GROUND_Y - ob.h;
          ob.vy = 0;
          ob.state = 'stuck';
        }
      } else {
        // travel left with world
        ob.x += ob.vx * (dt/1000);
      }
    } else {
      ob.x += ob.vx * (dt/1000);
    }
  }
  // remove off-screen obstacles
  obstacles = obstacles.filter(o => (o.x + (o.w||40) > -120) && o.active);
}

function checkCollisions(){
  // player's bounding box
  const ply = { x: player.x, y: player.y, w: player.w, h: player.h };
  for(let ob of obstacles){
    if(!ob.active) continue;
    if(ob.type==='spike' || ob.type==='spikeTall'){
      if(spikeCollision(ob, ply)) return true;
    } else if(ob.type==='saw'){
      // circle-rect collision
      const cx = ob.x + ob.w/2, cy = ob.y;
      const rx = ply.x, ry = ply.y, rw = ply.w, rh = ply.h;
      // closest point
      const closestX = clamp(cx, rx, rx+rw);
      const closestY = clamp(cy, ry, ry+rh);
      const dx = cx - closestX, dy = cy - closestY;
      const dist2 = dx*dx + dy*dy;
      if(dist2 <= (ob.r*ob.r)) return true;
    } else if(ob.type==='movingSpike' || ob.type==='fallSpike'){
      // rect collision with their bounding box (for simplicity)
      const box = {x: ob.x, y: (ob.y || (GROUND_Y - ob.h)), w: ob.w, h: ob.h};
      if(rectsOverlap(box, ply)) return true;
    }
  }
  return false;
}

/* ---------- level up ---------- */
function onLevelUp(lv){
  targetBg = levelColors[Math.min(levelColors.length-1, lv-1)];
  bgLerpT = 0;
  showMessage(`ğŸ¯ Ù…Ø³ØªÙˆÙ‰ ${lv}!`, 1400);
  if(lv >= 3) player.wings = true;
  if(lv >= 5) player.color = '#a30000';
  if(lv >= 8) player.color = '#440000';
  // raise speed slightly
  speed += 12;
}

/* ---------- UI message ---------- */
let msgTimeout = null;
function showMessage(txt, ms=1500){
  if(msgTimeout) clearTimeout(msgTimeout);
  messageEl.textContent = txt;
  messageEl.classList.add('show');
  msgTimeout = setTimeout(()=>{ messageEl.classList.remove('show'); msgTimeout = null; }, ms);
}

/* ---------- game loop ---------- */
function gameLoop(ts){
  if(!running) return;
  if(!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;

  // background lerp
  if(bgLerpT < 1){
    bgLerpT = Math.min(1, bgLerpT + 0.012);
    const c1 = hexToRgb(bgColor);
    const c2 = hexToRgb(targetBg);
    const r = Math.round(lerp(c1.r,c2.r,bgLerpT));
    const g = Math.round(lerp(c1.g,c2.g,bgLerpT));
    const b = Math.round(lerp(c1.b,c2.b,bgLerpT));
    canvas.style.background = `rgb(${r},${g},${b})`;
    if(bgLerpT===1) bgColor = targetBg;
  }

  // world scroll (distance)
  worldX += speed * (dt/1000);

  // spawn by distance
  if(worldX - lastSpawnAt > spawnDistance + (Math.random()*160 - 80)){
    spawnObstacles();
    lastSpawnAt = worldX;
    // vary spawnDistance slightly with level
    spawnDistance = Math.max(180, spawnDistance - (level*2) + Math.random()*80);
  }

  // physics (player)
  player.y += player.vy;
  if(player.y + player.h < GROUND_Y){
    player.vy += gravity * (dt/16.67);
    player.onGround = false;
  } else {
    player.y = GROUND_Y - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  // update obstacles
  updateObstacles(dt);

  // render
  ctx.clearRect(0,0,W,canvas.height);
  drawGround();
  // draw obstacles (sorted so saws render above)
  for(let ob of obstacles){
    if(ob.type==='spike') drawSpike(ob);
    else if(ob.type==='spikeTall') drawSpikeTall(ob);
    else if(ob.type==='saw') drawSaw(ob);
    else if(ob.type==='movingSpike' || ob.type==='fallSpike'){
      // draw as dark diamond spike
      const x = ob.x, y = (ob.y || (GROUND_Y - (ob.h||40)));
      ctx.save();
      ctx.translate(x + (ob.w/2), y + (ob.h/2));
      ctx.rotate(Math.PI/4);
      ctx.fillStyle = '#eee';
      ctx.fillRect(-(ob.w/2), -(ob.h/2), ob.w, ob.h);
      ctx.restore();
    }
  }
  drawPlayer();

  // points & level
  points += dt * 0.02 * (speed/180);
  scoreEl.textContent = 'Ø§Ù„Ù†Ù‚Ø§Ø·: ' + Math.floor(points);
  const newLevel = Math.floor(points / 150) + 1;
  if(newLevel !== level){
    level = newLevel;
    onLevelUp(level);
  }
  levelEl.textContent = level;

  // best
  if(Math.floor(points) > best){ best = Math.floor(points); bestEl.textContent = 'Ø§Ù„Ø£ÙØ¶Ù„: ' + best; localStorage.setItem('dino_best', best); }

  // collisions
  if(checkCollisions()){
    gameOver();
    return;
  }

  rafId = requestAnimationFrame(gameLoop);
}

function startRunning(){
  startScreen.style.display = 'none';
  endScreen.style.display = 'none';
  running = true;
  lastTime = performance.now();
  points = 0;
  worldX = 0;
  lastSpawnAt = 0;
  obstacles = [];
  player = { x:80, y: GROUND_Y - 60, w:48, h:48, vy:0, onGround:true, color:'#ff3333', wings:false };
  gravity = parseFloat(sliderGravity.value);
  jumpForce = parseInt(sliderJump.value,10);
  try{ if(!muteState && bgMusic.src){ bgMusic.currentTime = 0; bgMusic.play().catch(()=>{}); } }catch(e){}
  rafId = requestAnimationFrame(gameLoop);
}

function stopRunning(){
  running = false;
  if(rafId) cancelAnimationFrame(rafId);
  try{ if(bgMusic){ bgMusic.pause(); bgMusic.currentTime = 0; } }catch(e){}
}

/* ---------- controls ---------- */
startEasy.addEventListener('click', ()=>{ applyDifficulty('easy'); startRunning(); });
startNormal.addEventListener('click', ()=>{ applyDifficulty('normal'); startRunning(); });
startHard.addEventListener('click', ()=>{ applyDifficulty('hard'); startRunning(); });

btnRestart.addEventListener('click', ()=>{
  stopRunning();
  startRunning();
});
restartFromEnd.addEventListener('click', ()=>{ stopRunning(); startRunning(); });

function shareScore(val){
  const text = `Ù„Ø¹Ø¨Øª Dino Devil ÙˆØ­Ù‚Ù‚Øª ${val} Ù†Ù‚Ø·Ø©! Ø¬Ø±Ø¨Ù‡Ø§ Ø§Ù„Ø¢Ù†!`;
  if(navigator.share){
    navigator.share({ title:'Dino Devil', text: text }).catch(()=>{ copyToClipboard(text); });
  } else { copyToClipboard(text); alert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©'); }
}
btnShare.addEventListener('click', ()=> shareScore(Math.floor(points)));
document.getElementById('shareFromEnd')?.addEventListener('click', ()=> shareScore(Math.floor(points)));
function copyToClipboard(txt){ navigator.clipboard?.writeText(txt).catch(()=>{}); }

muteBtn.addEventListener('click', ()=>{
  muteState = !muteState;
  muteBtn.textContent = muteState ? 'ğŸ”‡' : 'ğŸ”Š';
  if(muteState){ try{ bgMusic.pause(); }catch(e){} } else { try{ if(bgMusic.src) bgMusic.play().catch(()=>{}); }catch(e){} }
});

/* ---------- init ---------- */
window.addEventListener('load', ()=>{ /* nothing special */ });

</script>
</body>
</html>
